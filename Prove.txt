import libsbml
import random
import math

# ======= 1. Carica il modello SBML =======
def load_sbml_model(filename):
    reader = libsbml.SBMLReader()
    doc = reader.readSBML(filename)
    if doc.getNumErrors() > 0:
        doc.printErrors()
        raise Exception("Errore nella lettura del file SBML.")
    model = doc.getModel()
    if model is None:
        raise Exception("Nessun modello trovato.")
    return model

# ======= 2. Estrai specie =======
def extract_species(model):
    species = {}
    for s in model.getListOfSpecies():
        if s.getHasOnlySubstanceUnits():  # Ignora se non ha quantità
            continue
        species[s.getId()] = s.getInitialAmount()
    return species


'''if compartment_id is None:
                species[s.getId()] = (s.getName(), None)
                continue

            compartment = model.getCompartment(compartment_id)
            if compartment is None:
                species[s.getId()] = (s.getName(), None)
                continue

            volume = compartment.getSize()
            if volume is None:
                species[s.getId()] = (s.getName(), None)
                continue

            species[s.getId()] = (s.getName(), volume * s.getInitialConcentration())'''





# ======= 3. Estrai reazioni =======
def extract_reactions(model):
    compartment_reaction_map = {}
    numCompartments = model.getNumCompartments()
    if numCompartments == 0:
        compartment_reaction_map[UNIQUE_COMPARTMENT] = {}

    for r in model.getListOfReactions():
        reaction = {
            "id": r.getId(),
            "reactants": {},
            "products": {},
            "rate": None,
            "parameters": {}
        }

        compartment_name = r.getCompartment()
        # 3 cases:
        #  1. no compartment,
        #  2. some compartments and some reactions without compartment,
        #  3. some compartment and all the reactions has a compartment

        if compartment_name is None :
            if numCompartments > 0: # We have more compartments and just some reactions without compartment
                return None
            # Any compartments
            compartment_name = UNIQUE_COMPARTMENT

        # Reactans' coefficients
        reactants_ids = []
        for sr in r.getListOfReactants():
            reactants_ids.append(sr.getId()) #usefull to check if the kinectik law is mass action law
            reaction["reactants"][sr.getSpecies()] = sr.getStoichiometry()

        # Products' coefficients
        for sp in r.getListOfProducts():
            reaction["products"][sp.getSpecies()] = sp.getStoichiometry()

        # Kinectic law
        kinetic_law = r.getKineticLaw()
        if kinetic_law is None:
            return None

        formula = kinetic_law.getFormula()
        if not is_mass_action(formula, reactants_ids):
            return None

        reaction["rate"] = formula

        #TODO: supporto ad altre o qualsiasi legge cineticha

        #TODO: inferimento della legge cinetica da dati forniti tramite file csv.
        # 1. Come diciamo quale reazione deve passare da l'inferimento?
        # 2. Generazione punti dati da cui inferire?

        # Parametri
        params = {p.getId(): p.getValue() for p in kinetic_law.getListOfParameters()}
        reaction["parameters"] = params

        compartment_reaction_map[compartment_name].append(reaction)
        #TODO: se fosse il primo inserimento per quella chiave specifica?

    return compartment_reaction_map

# ======= 4. Valuta il tasso di una reazione dinamicamente =======
def evaluate_rate(formula, species, parameters):
    # Esegui formula in un contesto sicuro con solo species e parametri
    local_dict = {}
    local_dict.update(species)
    local_dict.update(parameters)
    try:
        return eval(formula, {"__builtins__": None, "math": math}, local_dict)
    except:
        return 0.0

# ======= 5. Simulazione Gillespie =======
def gillespie_simulation(species, reactions, t_max):
    time = 0.0
    history = [(time, species.copy())]

    while time < t_max:
        # Calcola propensità (tassi) di ogni reazione
        propensities = []
        for r in reactions:
            a = evaluate_rate(r["rate_formula"], species, r["parameters"])
            propensities.append(a)

        a0 = sum(propensities)
        if a0 == 0:
            break  # Nessuna reazione può avvenire

        # Tempo alla prossima reazione
        r1 = random.random()
        tau = -math.log(r1) / a0
        time += tau

        # Quale reazione avviene
        r2 = random.random() * a0
        cumulative = 0.0
        for i, a in enumerate(propensities):
            cumulative += a
            if r2 < cumulative:
                chosen = i
                break

        # Aggiorna specie
        r = reactions[chosen]
        for s, stoich in r["reactants"].items():
            species[s] -= stoich
        for s, stoich in r["products"].items():
            species[s] += stoich

        # Salva stato
        history.append((time, species.copy()))

    return history

# ======= 6. Esegui tutto =======
if __name__ == "__main__":
    filename = "model.xml"  # <-- cambia con il tuo file

    model = load_sbml_model(filename)
    species = extract_species(model)
    reactions = extract_reactions(model)

    result = gillespie_simulation(species, reactions, t_max=50.0)

    # Stampa i risultati
    for t, state in result:
        print(f"t={t:.3f}", state)



















